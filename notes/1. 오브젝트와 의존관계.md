### 디자인 패턴: 상속을 통한 확장
* **템플릿 메소드 패턴: template method pattern**
  * 슈퍼 클래스에 기본적인 로직의 흐름을 만들고, 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 뒤 서브 클래스에서 해당 메소드를 필요에 맞게 구현해서 사용하도록 하는 디자인 패턴
  * 상속을 통해 슈퍼클래스의 기능을 확장할 때 사용하는 대표적인 방법이다.
  * 서브클래스에서 선택적으로 오버라이드할 수 있도록 만들어둔 슈메소드를 `훅(hook) 메소드`라고 한다.
  * 서브클래스에서는 `추상 메소드`를 구현하거나, `훅 메소드`를 오버라이드하는 방법을 통해 기능을 확장한다.
  ```java
  public abstract class Super {
        // 템플릿 메소드
        public void templateMethod() {
            // 기본 알고리즘 코드
            hookMethod();
            abstractMethod();
        }
  
        protected void hookMethod() { }  // hook 메소드
        public abstract void abstractMethod();  // 추상 메소드
  }
  
  public class Sub1 extends Super {
        protected void hookMethod() {
            ...  // hook 메소드 오버라이드
        }
        public void abstractMethod() {
            ... // 추상 메소드 반드시 구현
        } 
  } 
  ```
* **팩토리 메소드 패턴: factory method pattern**
  * 서브클래스에서 구체적인 오브젝트 생성 방법을 결정하는 디자인 패턴
    * 슈퍼 클래스에서는 서브클래스에서 구현할 메소드를 호출해서 필요한 타입의 오브젝트를 가져와 사용한다.  
    * 이 메소드는 주로 인터페이스 타입으로 오브젝트를 리턴한다.  
    * 따라서 어떤 클래스의 오브젝트를 만들어 리턴할지는 서브클래스가 결정하고, 슈퍼클래스의 관심사가 아니다.  
  * 서브클래스에서 오브젝트 생성 방법과 클래스를 결정할 수 있도록 미리 정의해둔 메소드를 `팩토리 메소드`라고 한다.
  * 오브젝트 생성 방법을 슈퍼클래스의 기본 코드에서 독립시키는 방법을 `팩토리 메소드 패턴`이라고 한다.

  ![](../../../Pictures/Screenshot from 2022-09-13 23-51-27.png)
   
  * getConnection()이 팩토리 메소드
  * 서브클래스의 getConnection()을 통해 만들어진 Connection 오브젝트의 종류가 달라진다.
  * UserDao는 Connection 인터페이스 타입의 오브젝트라는 것만 알면되므로 팩토리 메소드 패턴
  * [참고](https://jdm.kr/blog/180)
  
* **상속의 단점**  
  * 위 디자인 패턴들은 상속을 사용했다는 단점이 있다. 아래는 상속의 단점이다.
  * 자바는 클래스의 다중상속을 허용하지 않는다. 
    * 따라서 다른 목적으로 상속을 적용할 수 없다.
  * 상속을 통한 상하위 클래스의 관계는 밀접하다.
    * 서브 클래스는 슈퍼클래스의 기능을 직접 사용할 수 있다.
    * 그래서 슈퍼클래스 내부의 변경이 있을 때 서브 클래스를 수정해야 할 수도 있다.

### 인터페이스 도입
* 인터페이스란
  * 어떤 일을 하겠다는 기능만 정의하고, 구체적인 기능은 구현 클래스에 맡김
  * 구현클래스의 정보는 감추고 인터페이스를 사용 : `다형성`
  ```java
  # 인터페이스 정의
  public interface ConnectionMaker {
      public Connection makeConnection() throws ClassNotFoundException, SQLException;
  }
  
  # 인터페이스 구현 클래스, makeConnection() 메소드 정의
  public class DConnectionMaker implements ConnectionMaker {
      public Connection makeConnection() throws ClassNotFoundException, SQLException {
          Class.forName("com.mysql.jdbc.Driver");
          return DriverManager.getConnection(
                "jdbc:mysql://localhost:53306/springbook", "spring", "book");
     }
  }
  ```
  ```java
  public class UserDao {
    private ConnectionMaker connectionMaker;
  
    # 인터페이스 타입으로 구현 클래스의 인스턴스를 받아 사용
    # 즉 UserDao는 어떤 구현 클래스를 사용해야할지 신경쓰지 않아도 된다.
    public UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker;
    }
    ...
  }
  
  // UserTest에서 ConnectionMaker 인터페이스의 구현 클래스 인스턴스를 생성하고, UserDao 생성자 파라미터에 넣어준다.
  public class UserDaoTest {
      public static void main(String[] args) throws ClassNotFoundException, SQLException {
          ConnectionMaker connectionMaker = new DConnectionMaker();
          UserDao dao = new UserDao(connectionMaker);
      }
  }
  ```
  
### 원칙과 패턴
* 개방 폐쇄 원칙
  * 인터페이스를 통해 확장에는 열려있고, 인터페이스를 이용하는 클래스는 변경에 닫혀있다.
  